#ifndef INC_07_HILL_CLIMBING_STATE_H
#define INC_07_HILL_CLIMBING_STATE_H

#include <vector>
#include <iostream>
#include <algorithm>


using namespace std;

/**
 * The State class represents a configuration of knights on a 4x3 chessboard. It encapsulates the current state
 * of the board along with methods for calculating the heuristic score, generating possible successor states,
 * and performing other operations related to the problem of exchanging knights.
 *
 */
class State {
private:
    ///
    /// A vector representing the current configuration of knights on the chessboard. Each element of the vector
    /// corresponds to a square on the board, where 'W' represents a white knight, 'B' represents a black knight, and
    /// 'E' represents an empty square.
    ///
    vector<char> state;
    ///
    /// An integer representing the heuristic score of the current state. This score is used to estimate the cost of
    /// reaching the goal state from the current state.
    /// The smaller the score, the closer to the goal state.
    ///
    int heuristic{};

    /**
     * Method to check if a move to a given position on the board is valid.
     * This method verifies whether moving a knight to the specified row and column on the chessboard is allowable.
     *
     * @brief Determine the validity of a knight move on the chessboard.
     *
     * @param row The row index of the target position.
     * @param col The column index of the target position.
     * @param actualCol The total number of columns on the chessboard.
     * @param actualRow The total number of rows on the chessboard.
     *
     * @return True if the move is valid, false otherwise.
     *
     * @details A move is considered valid if:
     *          - The target position is within the borders of the chessboard, specified by 'actualRow' and 'actualCol'.
     *          - The target position is not at the ignored positions (1,1) and (2,1), which are excluded to optimize
     *            performance and reduce unnecessary state generation.
     *          - There are no more than three knights occupying the middle positions (1,0), (1,2), (2,0), and (2,2),
     *            as depicted in the image below:
     *            <br><img src="https://i.imgur.com/GGDrBdP.png">
     */
    bool isValidMove(int row, int col, int actualCol, int actualRow);

    /**
     * Method to generate possible successor states by moving a knight located at a given position on the board.
     * This method calculates all valid moves for a knight at the specified position and generates successor states
     * by moving the knight to each valid position.
     *
     * @param position The index of the knight's current position on the board.
     * @param currentState The current state of the chessboard represented as a vector of characters.
     *
     * @return A vector containing all possible successor states generated by moving the knight.
     */
    vector<State> moveChess(int position, vector<char> currentState);

    /**
     * Method to calculate the heuristic score of the current state based on the distances of knights from their goal rows.
     * This method evaluates the current state of the chessboard and computes a heuristic score to estimate the cost
     * of reaching the goal state. The heuristic score is determined by calculating the distance of each knight's
     * row from its corresponding goal row in the goal state, summing all the differences, and dividing the total by 4
     * to obtain an underestimated heuristic.
     *
     * @details
     * <p>
     * Example:
     * Suppose the current state of the chessboard is:
     * <pre>
     *   W E B <br>
     *   E E B <br>
     *   W E B <br>
     *   W E E
     * </pre>
     * and the goal state is:
     * <pre>
     *   B B B <br>
     *   E E E <br>
     *   E E E <br>
     *   W W W
     * </pre>
     * The heuristic score would be calculated as follows:
     * </p>
     * <ul>
     *   <li>
     *     For the white knights:
     *     <ul>
     *       <li>Distance of first white knight's row from its goal row: |0 - 3| = 3</li>
     *       <li>Distance of second white knight's row from its goal row: |2 - 3| = 1</li>
     *       <li>Distance of third white knight's row from its goal row: |3 - 3| = 0</li>
     *     </ul>
     *   </li>
     *   <li>
     *     For the black knights:
     *     <ul>
     *       <li>Distance of first black knight's row from its goal row: |0 - 0| = 0</li>
     *       <li>Distance of second black knight's row from its goal row: |1 - 0| = 1</li>
     *       <li>Distance of third black knight's row from its goal row: |2 - 0| = 2</li>
     *     </ul>
     *   </li>
     *   <li>Total heuristic score: floor((3 + 1 + 0 + 0 + 1 + 2) / 4 )= floor(7/4) = 1</li>
     * </ul>
     */
    void calculateHeuristic();


public:
    /**
     * Constructor method to initialize the state of the chessboard to its initial configuration.
     * This constructor sets up the initial state of the chessboard with three white knights (''W') at the top row
     * and three black knights ('B') at the bottom row. The empty squares are represented by 'E'.
     *
     * <p>
     * The initial state of the chessboard:
     * <pre>
     *   W W W <br>
     *   E E E <br>
     *   E E E <br>
     *   B B B
     * </pre>
     * </p>
     */
    explicit State();

    /**
     * Constructor method to initialize the state of the chessboard with a custom configuration.
     * @details This constructor sets up the state of the chessboard using the provided vector of characters.
     * Each character represents the occupant of a square on the chessboard ('W' for white knight,
     * 'B' for black knight, and 'E' for an empty square).
     *
     * @param _state A vector of characters representing the configuration of the chessboard.
     *               'W' represents a white knight, 'B' represents a black knight, and 'E' represents an empty square.
     */
    explicit State(const vector<char> &_state) : heuristic(0) {
        for (char idx: _state) {
            state.push_back(idx);
        }
    }

    /**
    * Getter method to retrieve the current state of the chessboard.
    *
    * @return A vector of characters representing the current configuration of the chessboard.
    */
    [[nodiscard]] vector<char> getState() const;

    /**
     * Getter method to retrieve the heuristic score of the current state.
     *
     * @return The heuristic score of the current state.
     */
    [[nodiscard]] int getHeuristic() const;

    /**
     * Method to check if the current state is the goal state.
     * This method evaluates whether the current state of the chessboard matches the goal state,
     * where the white knights are positioned at the bottom row and the black knights at the top row.
     *
     * @return True if the current state is the goal state, false otherwise.
     */
    [[nodiscard]] bool isGoal() const;

    /**
     * @brief Generates all possible successor states reachable from the current state by moving knights.
     *
     * @details This method iterates through each knight on the chessboard, generates all possible moves for each knight
     * using the `moveChess` method, and adds the resulting states to the list of generated states.
     * It considers both white and black knights separately and incorporates the `moveChess` method to compute
     * the possible moves for each knight.
     *
     * @return A vector of State objects representing all possible successor states reachable from the current state.
     *
     * @see State::moveChess()
     */
    vector<State> generateStates();

    /**
     * @brief Prints the current state of the chessboard.
     */
    void print() const;

    /**
     * @brief This method determines whether the provided state is identical to the current state.
     *
     * @param state The state to compare with the current state.
     *
     * @return True if the states are equal, false otherwise.
     */
    bool equals(State state);
};

#endif //INC_07_HILL_CLIMBING_STATE_H