problem statement:
    There are n coins placed in a row. The goal is to form n/2 pairs of them by a sequence of moves. On the first move a 
    single coin has to jump over one coin adjacent to it, on the second move a single coin has to jump over two adjacent 
    coins, on the third move a single coin has to jump over three adjacent coins, and so on, until after n/2 moves n/2 coin 
    pairs are formed. (On each move, a coin can jump right or left but it has to land on a single coin. Jumping over a coin 
    pair counts as jumping over two coins. Any empty space between adjacent coins is ignored.) Determine all the values 
    of n for which the problem has a solution and design an algorithm that solves it in the minimum number of moves for 
    those nâ€™s.
    Design greedy algorithm to find the minimum number of moves.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

assumptions: 
    represent coins with an array of ones of size n, if its space is empty then 0, if in contains a pair then two.
        0 means no coin at a position i 
        1 means 1 coin at a position i
        2 means 2 coins at a position i
    jumping over a coin: 1 1 --> 2 0

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

constrains: 
    number of coins n is an even number to be able to make n/2 coin pairs 
    jump only over a single coin 
    1st move jump only 1 place 
    2nd move jump 2 places 
    3rd move jump 3 places
    ........................
    n/2 move jump n/2 places
    Any empty space between adjacent coins is ignored

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------    
    
pseudocode:
function check_possible(n):
    if n > 0:
        for i from 2 to 30:
            if n == (2^i) - 2:
                return true
        return false
    else:
        return false


function check_done(coins, size):
    if numberOfTwos == size/2 and numberOfZeros == size/2:
        return true
    else:
        return false

function jump(coins, coin1_position, coin2_position):
    coins[coin1_position] = 0
    coins[coin2_position] = 2

function minimum_moves(coins, size):
    if not check_possible(size):
        return -1
    moves = 0
    while not check_done(coins, size):
        for i from 0 to size-1:
            if coins[i] == 1:
                sum = 0
                j = 0
                while sum < moves + 1:
                    sum += coins[i + j]
                    j++
                if coins[i + j] == 1:
                    jump(coins, i, i + j)
                    moves++
    return moves

main:
    coins = {1, 1, 0, 0, 2, 2, 0, 0}
    result = minimum_moves(coins, size_of(coins))
    if result == -1:
        output "Error"
    else:
        output "Minimum number of moves: " + result
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

complexity analysis: 

check_possible(int n): O(1)
check_done(int coins[], int size): O(n)
jump(int coins[], int coin1_position, int coin2_position): O(1).
minimum_moves(int coins[], int size): O(n^2) , omega(n)


time complexity of algorithm O(n^2)

